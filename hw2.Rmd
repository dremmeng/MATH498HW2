---
title: 'MATH 498 HW2'
author: "Drew Remmenga"
output:
  pdf_document: default
  html_notebook: default
---
1.a.
```{r}
library(splines)
HW2Test<- function(x){
pgamma( x, shape =10, scale =.02) - .5*x
}
xGrid <- seq( 0,1, length.out=200)
y<-HW2Test(xGrid)
fit1<-lm(y ~ poly(xGrid, 17, raw=TRUE))
lm(y ~ poly(xGrid, 17, raw=TRUE))
fit2<-lm(y ~ poly(xGrid, 15, raw=TRUE))
lm(y ~ poly(xGrid, 15, raw=TRUE))
fit3<-lm(y ~ poly(xGrid, 13, raw=TRUE))
lm(y ~ poly(xGrid, 13, raw=TRUE))
fit4<-lm(y ~ poly(xGrid, 11, raw=TRUE))
lm(y ~ poly(xGrid, 11, raw=TRUE))
```
1.b.
```{r}
plot(xGrid, HW2Test(xGrid), col="Red")
pred1<- predict(fit1)
pred2<- predict(fit2)
pred3<- predict(fit3)
pred4<- predict(fit4)
lines(xGrid, pred1, col='Blue', lwd=2)
lines(xGrid, pred2, col='Green', lwd=2)
lines(xGrid, pred3, col='Black', lwd=2)
lines(xGrid, pred4, col='Yellow', lwd=2)
legend("topleft", legend=c("Actual", "Degree 17", "Degree 15", "Degree 13", "Degree 11"),
       col=c("Red", "Blue", "Green", "Black", "Yellow"), lty=1:2, cex=0.8)
title("Different degree Polynomials fit to the Gamma function")
```
1.c. Degrees 17,15,13, and 11.
```{r}
sqrt( mean( ( y - pred1)^2 ))
sqrt( mean( ( y - pred2)^2 ))
sqrt( mean( ( y - pred3)^2 ))
sqrt( mean( ( y - pred4)^2 ))
```
2.a.
```{r}
xGrid<- seq( 0,1,length.out=150)
KN<- seq( 0,1,length.out=10)
naturalSplineBasis <- function(sGrid,
                               sKnots,
                               degree = 3,
                               derivative = 0) {
  boundaryKnots<- c( min(sKnots),max(sKnots))
  sKnots0<- c( rep( boundaryKnots[1],degree),sort(sKnots),
               rep( boundaryKnots[2],degree) )
  testRight<- sGrid < min(sKnots) 
  testLeft <- sGrid > max(sKnots)             
  if( any(testRight |testLeft) )
  {stop("some points for evaluation outside knot range.")}
               
  basis <- splineDesign(sKnots0, sGrid,
                        ord= degree+1, outer.ok=TRUE,
                        derivs=derivative)
  # set up constraints to enforce natural BCs.
  const <- splineDesign(sKnots0, boundaryKnots, ord = degree+1,
                        derivs = c(2,2)) 
  qr.const <- qr(t(const))
  QBasis<- t(qr.qty( qr.const, t(basis) ))
  basis <- QBasis[,-(1:2)]
  basis
  
  return( basis )
  
}
B<- naturalSplineBasis( xGrid, sKnots=KN)
matplot( xGrid, B, type="l", lty=1)
```
Just one.
2.b.
```{r}
NBSFit<- function( x, y, xGrid){
N<- length( x)
AData<- naturalSplineBasis( x, sKnots=x)
coef<- solve( AData, y)
AGrid<- naturalSplineBasis( xGrid, sKnots=x )
yFit <-AGrid%*%coef
return( yFit)
}
y <- HW2Test(xGrid)
NBSFit(xGrid,y,xGrid)
```
$\int_{-\infty}^{\infty} \sqrt(2) cos(2\pi x)*\sqrt(2) cos(2\pi x)=1$
$\int_{-\infty}^{\infty} \sqrt(2) sin(2\pi x)*\sqrt(2) sin(2\pi x)=1$
$\int_{-\infty}^{\infty} \sqrt(2) cos(4\pi x)*\sqrt(2) cos(4\pi x)=1$
$\int_{-\infty}^{\infty} \sqrt(2) sin(4\pi x)*\sqrt(2) sin(4\pi x)=1$